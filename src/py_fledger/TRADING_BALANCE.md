# TRADING_BALANCE — как работает trading_balance в py_fledger

Этот документ подробно описывает назначение, модель данных, алгоритм и нюансы работы метода `Book.trading_balance()` в пакете `py_fledger`.

Содержание
- Термины и модель данных
- Назначение trading_balance
- Алгоритм по шагам
- Знаки и курсы: почему «делитель»
- Результат и формат возвращаемых данных
- Примеры и сценарии
- Важные нюансы и ограничения
- Производительность и индексация
- Частые вопросы (FAQ)

## Термины и модель данных
- Базовая валюта — первая валюта, созданная в системе. Её курс всегда считается 1.0. Все суммы в базовой валюте интерпретируются без пересчёта.
- Иностранная валюта — любая валюта, отличная от базовой. Для транзакций по счётам в иностранной валюте указывается курс как «делитель» для получения эквивалента в базовой.
- Курс (exchangeRate) — делитель. Сумма в иностранной валюте делится на курс, чтобы получить сумму в базовой валюте.
  - Пример: 3000 THB при курсе 30.0 ⇒ 3000 / 30.0 = 100 (в базовой валюте USD).
- Транзакция — запись движения по одному счёту: `amount (BIGINT)`, `credit (bool)`, `exchangeRate (float)`, `memo`, `meta`.
- Журнальная запись (JournalEntry) — набор сбалансированных транзакций (дебет = кредит в базовой валюте).

## Назначение trading_balance
Метод `trading_balance()` возвращает изменение «торгового» баланса по валютам за заданный период и его проекцию в базовую валюту. Это агрегированный отчёт, в котором:
- По каждой валюте вычисляется итог `debits_sum - credits_sum` (в НОМИНАЛЕ этой валюты) за период.
- Отдельно считается «base» — сумма всех валют, пересчитанных в базовую по текущему (последнему сохранённому) курсу.

Важно: пересчёт «base» использует актуальный курс из таблицы `currencies`, а не курсы отдельных транзакций в прошлом. Это упрощение — решение для быстрого высокоуровневого контроля позиции.

## Алгоритм по шагам
Вход: `options: { startDate?: datetime, endDate?: datetime }`.
- Если период не задан — берётся весь интервал: от эпохи (`1970-01-01 00:00:00 UTC`) до `now(UTC)`.
- Даты должны быть timezone-aware (в py_fledger используется `datetime.now(timezone.utc)`).

Шаги:
1) Получить список валют (`currencies`).
2) Для каждой валюты:
   - Найти все транзакции в заданном интервале времени, у которых счёт (`account`) номинирован в этой валюте.
   - Посчитать:
     - `credits_sum` = сумма `amount` по транзакциям с `credit == True`.
     - `debits_sum`  = сумма `amount` по транзакциям с `credit == False`.
   - Вычислить разницу в НОМИНАЛЕ валюты: `diff = debits_sum - credits_sum`.
   - Сохранить `diff` как строку в `result.currency[code]`.
   - Пересчитать в базовую: 
     - Если валюта — базовая: `rate = 1.0`.
     - Иначе: `rate = currency.exchange_rate` (последний сохранённый для этой валюты).
     - `result.base += diff / rate`.
3) В конце округлить `result.base` до целого и вернуть как строку.

SQL-эквиваленты (агрегации):
- Для каждой валюты C:
  - `credits_sum(C) = SUM(t.amount WHERE t.credit = true AND t.createdAt BETWEEN [start,end] AND t.account.currencyId = C.id)`
  - `debits_sum(C)  = SUM(t.amount WHERE t.credit = false AND t.createdAt BETWEEN [start,end] AND t.account.currencyId = C.id)`
  - `diff(C) = debits_sum(C) - credits_sum(C)`
  - `base += diff(C) / rate(C)`

## Знаки и курсы: почему «делитель»
- Выбор знаков соответствует бухгалтерской логике: дебет увеличивает остаток по счёту, кредит — уменьшает, на уровне агрегации валюты это отображается как `debits_sum - credits_sum`.
- Курс — делитель. Это означает, что сумма в иностранной валюте делится на курс для получения эквивалента в базовой валюте. Это согласовано со всей системой (балансировка проводок и пересчёты в базе).

## Результат и формат возвращаемых данных
Метод возвращает словарь вида:
```
{
  "currency": {
    "USD": "-6997",
    "RUB": "0",
    ...
  },
  "base": "-6997"
}
```
- `currency[code]` — строка-целое (номинал валюты), итог `debits_sum - credits_sum` за период.
- `base` — строка-целое, сумма по всем валютам, пересчитанная в базовую валюту по актуальным курсам.

## Примеры и сценарии
Ниже — синтетический сценарий в духе unit-тестов пакета:
1) Заводим валюты: `USD` (база), `RUB`.
2) Проводка пополнения пользователя в USD: дебет `Assets:usdt` 10000, кредит `UserBalances:1` 10000.
   - По валюте USD дебеты и кредиты взаимно компенсируются (diff USD = 0).
3) Внутренний перевод USD между своими счетами (дебет/кредит в USD) — diff по USD остаётся 0.
4) Пополнение в RUB: дебет `Assets:bank:AlfaBank` 600300 RUB с курсом 60.03, кредит `UserBalances:1` 10000 USD.
   - По RUB: дебеты +600300, кредиты 0 ⇒ diff RUB > 0.
   - По USD: кредиты +10000 добавляются к уже имевшимся кредитам.
5) Меняем курс RUB позже (другая транзакция в RUB с курсом 70) — в таблице валют обновляется `exchange_rate` для RUB.
6) Получаем `trading_balance()` без ограничений по дате — он вернёт:
   - По валютам: номинальные суммы (строки), например `RUB: "1300300"`, `USD: "-20000"` (в зависимости от сценария).
   - `base` — сумму, пересчитанную в базу по текущим курсам (не по историческим).
7) Обмен RUB→USD: кредит `RUB` (списание) и дебет `USD` (зачисление). Можно подобрать такие величины и курс, чтобы `RUB` позиция стала нулевой, а итог в базе отразил «потерю/прибыль» в USD.
   - В тестах демонстрируется, что после такой операции `RUB` становится `"0"`, а `USD` — отрицательным.
   - `base` = `USD`, если базовая валюта — USD.

Ключевая мысль: `currency[code]` — это номинал по валюте за период (сумма дебетов минус сумма кредитов), а `base` — это проекция всех этих номиналов в базовую валюту по текущим курсам валют.

## Важные нюансы и ограничения
1) Исторические курсы не используются при пересчёте `base`. Используется последний (актуальный) курс из `currencies`. Если требуется точный исторический PnL с учётом курсов на момент каждой транзакции — нужна отдельная аналитическая процедура.
2) Курс для валюты обновляется side-effect’ом при `Entry.commit()` — метод обновляет `currency.exchange_rate` по факту использования курса в транзакциях (для базовой валюты всегда 1.0).
3) Если для иностранной валюты курс ещё ни разу не задавался (нет транзакций с этой валютой), `trading_balance()` попытается делить на `None` — в текущей реализации этого следует избегать. Рекомендуется либо:
   - сначала провести хотя бы одну транзакцию по этой валюте с указанием курса;
   - либо вручную проставить курс в таблицу валют.
4) Временные зоны. В `py_fledger` использованы timezone-aware даты в UTC. Если вы передаёте свои даты, убедитесь, что они согласованы по таймзоне.
5) Отсутствие фильтрации по `meta`. `trading_balance()` не принимает `meta`-фильтр и агрегирует все транзакции за заданный период.
6) Типы: все суммы хранятся в `BIGINT` (целые). Возвращаемые значения — строки, чтобы исключить ошибки округления и переполнения при работе клиента.

## Производительность и индексация
- Текущая реализация вызывает по два агрегирующих запроса на каждую валюту (SUM дебетов и SUM кредитов). При десятках валют это эффективно, при сотнях/тысячах может потребоваться оптимизация (группировки в одном запросе).
- Рекомендуемые индексы (PostgreSQL):
  ```sql
  CREATE INDEX IF NOT EXISTS idx_transactions_account_created ON transactions (accountId, createdAt);
  CREATE INDEX IF NOT EXISTS idx_accounts_currency ON accounts (currencyId);
  ```
- Для SQLite индексы также полезны, но синтаксис может отличаться.

## Частые вопросы (FAQ)
- Почему `diff = debits - credits`?
  - Это согласовано с бухгалтерской трактовкой (дебет увеличивает, кредит уменьшает). На уровне валют позиция растёт дебетом и уменьшается кредитом.
- Почему `base` не совпадает с суммой всех пересчётов по курсу транзакций?
  - По задумке отчёта используется АКТУАЛЬНЫЙ курс из `currencies`, а не курсы на момент каждой транзакции. Это не исторический PnL, а моментальная проекция валютных позиций.
- Что если валюта базовая?
  - Для базовой валюты курс принудительно 1.0.
- Можно ли добавить фильтрацию по `meta`?
  - В текущей реализации — нет. Это можно внедрить как расширение API, но оно усложнит и перегрузит агрегаты.

## TL;DR
`trading_balance()` — это:
- По каждой валюте: `diff = Σ(debits) - Σ(credits)` в номинале валюты (строка-целое).
- `base` — сумма всех `diff / rate(currency)` по актуальным курсам (строка-целое).
- Быстрый инструмент контроля позиций по валютам за период — не предназначен для точного исторического пересчёта в базовую валюту.

## Диаграмма потоков
Подробные диаграммы доступны в отдельном файле:
- PlantUML: см. `TRADING_BALANCE_DIAGRAMS.md` (раздел PlantUML)
- Mermaid: см. `TRADING_BALANCE_DIAGRAMS.md` (раздел Mermaid)
