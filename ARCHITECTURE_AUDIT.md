# Архитектурный аудит пакета py_accountant

Дата: 2025-11-12
Аудитор: системный архитектор / Python

Источник контекста: rpg_py_accountant.yaml, README.md, docs/INTEGRATION_GUIDE.md, examples/telegram_bot/*, src/application/ports.py, src/presentation/cli/*, src/infrastructure/persistence/sqlalchemy/*, pyproject.toml.

## 0) Резюме (executive summary)

- Назначение пакета: ядро мультивалютного бухгалтерского учета (Clean Architecture, async-only runtime, Alembic — sync).
- Удобство интеграции в сторонние приложения (боты, веб, воркеры): 7.5/10 сейчас. Основные плюсы — чистые use case’ы, строгие протоколы портов, детальные примеры CLI и Telegram, понятная политика async/sync URL. Главный минус — отсутствует стабильный публичный «SDK-слой» в пакете `py_accountant` (нужно импортировать глубоко во внутренние модули), а также жесткое требование Python ≥ 3.13.
- Риски: путаница с dual-URL (runtime vs migration), фрагментарность публичного API, отсутствие явного фасада для типовых задач интегратора (создать UoW, выполнить use case, сериализовать ответ, обработать исключения).
- Рекомендации с наибольшей отдачей:
  1) Ввести стабильный слой SDK: `py_accountant.sdk.*` (фасады для UoW, настройки, логирования, частых use case’ов) и экспорт его из корневого пакета.
  2) Добавить «проверку окружения» и хелпер для dual-URL, чтобы ловить конфигурационные ошибки на старте.
  3) Стандартизовать публичные исключения и маппинг в «ошибки интегратора» (например, для HTTP/бота).
  4) Рассмотреть понижение минимальной версии Python до 3.11–3.12 при отсутствии критической зависимости от 3.13.

## 1) Соответствие Clean Architecture / RPG-графу

- RPG-граф подробный: узлы по домену, application (use cases async), infrastructure (SQLAlchemy, UoW), presentation (CLI). Присутствуют зависимости и тестовые цели. Это сильная сторона — навигация и трассировка требований в тесты выполнены хорошо.
- Межслойные зависимости корректные: application зависит от domain, infra реализует порты, presentation — тонкие контроллеры.
- В домене отсутствует I/O — плюс для тестопригодности.

## 2) Публичный API пакета и его стабильность

Сейчас `src/py_accountant/__init__.py` экспортирует только версию и демонстрационную функцию `add`. Для интегратора это означает необходимость импортировать из внутренних пространств имен:
- `infrastructure.persistence.sqlalchemy.uow.AsyncSqlAlchemyUnitOfWork`
- `application.use_cases_async.*`
- DTO из `application.dto.models`

Риски:
- Путь импортов может меняться при реорганизации.
- Новым пользователям сложно отличить «стабильные API» от «внутренних модулей».

Рекомендация: сформировать стабильный публичный слой `py_accountant.sdk`:
- `py_accountant.sdk.uow`: фабрики UoW (по URL/по Settings), типы из портов.
- `py_accountant.sdk.use_cases`: фасады для наиболее частых сценариев (валюты, аккаунты, леджер, отчеты, FX TTL plan/execute).
- `py_accountant.sdk.settings`: pydantic-settings (или лёгкая обёртка) с dual-URL правилами.
- `py_accountant.sdk.logging`: единая инициализация структурированного логирования.
- `py_accountant.sdk.errors`: публичные исключения (алиасы DomainError/ValidationError + общие IntegrationError).
- Переэкспортировать ключевые протоколы из `application.ports` (для typing у интегратора).

## 3) Удобство интеграции (боты/веб/воркеры)

Сильные стороны:
- Async-only ядро упрощает жизнь в современных фреймворках (FastAPI, aiogram, aiojobs).
- Чёткая дисциплина UoW: «одна операция — один Async UoW»; хорошие примеры в INTEGRATION_GUIDE.
- Форматы сериализации задокументированы (Decimal→str, datetime→UTC ISO8601).
- Telegram пример иллюстрирует DI и no-op bootstrap.

Точки трения:
- Нет готовой фабрики «validate env → создать UoW/логгер/настройки». Интеграторы дублируют однотипный код.
- Dual-URL правило (DATABASE_URL vs DATABASE_URL_ASYNC) легко нарушить в dev/CI. Отказ есть в alembic/env.py, но хотим раннюю проверку и в runtime.
- Отсутствует единый «контракт ошибок» для интегратора (какие исключения ловить и как маппить в ответы бота/HTTP).
- Требование Python >= 3.13 ограничивает аудиторию; императивно проверить, действительно ли используются 3.13-only возможности (например, PEP 695, новые typing-конструкции).

Предложения:
- Ввести `py_accountant.sdk.bootstrap` с функцией `init_app(settings|env) -> {logger, uow_factory, clock}`.
- Добавить `validate_env_dual_url()` с понятными текстами ошибок.
- Стандартизовать «ошибки верхнего уровня» (например, `py_accountant.sdk.errors.UserInputError`, `DomainViolation`, `UnexpectedError`), дать примеры маппинга для aiogram/FastAPI.

## 4) Миграции vs runtime (безопасность и DX)

- Alembic читает только sync URL и отклоняет async — хорошо и безопасно.
- Документация по dual-URL присутствует в нескольких местах — плюс, но есть риск рассинхронизации.

Улучшения:
- Добавить утилиту `py_accountant.sdk.env.check_migration_url(url: str)` для CI/локального preflight.
- В README/INTEGRATION_GUIDE дать традиционный пример `.env` и единый «готовый» запуск тестовой схемы (sqlite) через SDK.

## 5) DTO, сериализация, типы

- DTO и протоколы портов чёткие; сериализация JSON определена.
- Для интеграторов полезно иметь «JSON presenter» в SDK, чтобы не реинтерпретировать Decimal/datetime вручную.

Рекомендации:
- `py_accountant.sdk.json` с функциями `to_json(data)`, `from_json()` где это уместно.
- Минимальный pydantic-модельный слой для внешних контрактов (например, ввод в CLI/бота) без проникновения в домен.

## 6) Телеграм-бот: применимость

- Пример показывает DI и async UoW. Для production-паттерна хорошо бы:
  - Фабрика UoW из настроек с пулом/таймаутами (особенно для asyncpg).
  - Centralized error mapping.
  - Чёткая политика ретраев (например, повтор на транзиентные ошибки БД).

Рекомендации:
- Документировать «per-handler UoW» и конвейер обработки ошибок.
- Добавить готовые хелперы: `uow_factory_from_env()`, `map_exception_to_message()`.

## 7) Производительность и масштабирование

- Имеется docs/PERFORMANCE.md, однако на уровне SDK отсутствуют быстрые профилировочные крюки.
- Рекомендация: предоставить feature-flag логирования метрик (время транзакции use case, количество запросов).

## 8) Совместимость и зависимости

- Python: `>=3.13,<4.0`. Если нет критической привязки к 3.13 (PEP 695/typing), стоит оценить понижение до 3.11–3.12. Это резко расширит интеграторов.
- Минимальный внешний стек — хорошо; aiogram не тянут в зависимости — тоже плюс.

## 9) Качество документации

- README и INTEGRATION_GUIDE качественные; CLI Quickstart наглядный. Есть мелкие опечатки в RPG YAML.
- Предложение: короткий раздел в README «Как мы используем RPG» и «SDK для интеграторов (стабильные импорты)».

## 10) Предлагаемые рефакторинги (упорядочены по ROI)

1) Ввести публичный SDK-слой и стабильные импорты
   - Сущность: `py_accountant/sdk/{uow,use_cases,settings,logging,errors,json}.py`.
   - В `__init__.py` переэкспортировать SDK-объекты: `from .sdk import ...`.
   - Документация: раздел «SDK surface» + примеры (бот, FastAPI, cron).
   - Эффект: устойчивые импорты, снижение когнитивной нагрузки интегратора.

2) Bootstrap и проверка окружения
   - Функции: `load_settings_from_env()`, `validate_dual_url()`, `build_uow_factory(settings)`.
   - CLI и примеры переключить на SDK-хелперы для единообразия.

3) Публичные исключения и маппинг
   - Описать контракт: какие ошибки ожидать с application/domain слоёв.
   - Реализовать `map_exception(exc) -> {code, message}`.

4) JSON presenter
   - Функции сериализации для Decimal/datetime; опционально — pydantic-модели для внешних контрактов.

5) Совместимость Python (если возможно)
   - Автоаудит 3.11/3.12 с ruff/pytest; если зелёно — расширить `python = ">=3.11,<4.0"`.

6) Документация
   - Раздел «Используем RPG» в README; починка опечаток в rpg_yaml; свести правила dual-URL к одному месту и сослаться из других.

## 11) Дорожная карта (топологический порядок по RPG)

1) SDK-поверхность (независима от бизнес-логики)
   - Добавить пакет `py_accountant/sdk` и минимальные фасады, тесты на импорт/инициализацию и JSON сериализацию.
2) Bootstrap/env validation
   - Реализовать `validate_dual_url`, `bootstrap.init_app`.
3) Обновить примеры (Telegram/CLI) на SDK-хелперы
   - Сохранить обратную совместимость путей, но в README показать новый путь.
4) Документация/опечатки
   - README раздел «SDK surface» + fix typos в RPG YAML.
5) Опционально: расширение поддержки Python и performance-метрики

## 12) Краткий «интеграционный» рецепт (как должно стать)

```python
# Иллюстративный пример (SDK-слой будет добавлен в будущей задаче)
# from py_accountant.sdk import bootstrap, use_cases, json as sdk_json
# app = bootstrap.init_app()
# async with app.uow_factory():
#     balance = await use_cases.get_account_balance("Assets:Cash")
# print(sdk_json.to_human(balance))
```

Это снизит объем «интеграционного» кода и сделает точки входа стабильными.

---

Приложение A. Быстрый чек-лист соответствия
- Слои разделены: да
- Порты/протоколы ясны: да
- Публичный SDK-слой: нет (предложено)
- Документация по dual-URL: да (усилить runtime-проверку)
- Телеграм-паттерн UoW per handler: да (усилить bootstrap/error mapping)
- Совместимость Python: 3.13+ (предложено расширить)
- Тесты: юнит/интеграция/CLI — присутствуют

Приложение B. Найденные опечатки в RPG YAML (для исправления)
- «ил��» → «или», «Рекомен��уется» → «Рекомендуется», «инициалиация» → «инициализация»,
  «округле���ия» → «округления», «неверн��го» → «неверного», «н��-LedgerEntry» → «не-LedgerEntry»,
  «��еред» → «перед».

## Приложение C. Self-Prompt для архитектурного аудита (RPG методика)

Ниже формализованный промпт, который можно использовать повторно для системного архитектурного аудита py_accountant:

"""
Ты — системный архитектор и опытный Python-инженер. Проведи архитектурный аудит проекта py_accountant.

Цели аудита:
1. Оценить удобство использования пакета как библиотеки в сторонних async-приложениях (Telegram боты, веб-сервисы, воркеры).
2. Сформировать конкретные предложения по рефакторингу, повышающие DX (developer experience), стабильность и расширяемость.
3. Сформировать отчёт в формате Markdown (ARCHITECTURE_AUDIT.md) рядом с rpg_py_accountant.yaml.

Обязательные источники контекста: rpg_py_accountant.yaml (граф), README.md, docs/INTEGRATION_GUIDE.md, src/application/ports.py, примеры Telegram (examples/telegram_bot/*), инфраструктурные файлы (uow, repositories_async, async_engine), pyproject.toml.

Используй методику Repository Planning Graph (RPG):
- Узлы → модули/файлы/компоненты; рёбра → зависимости.
- Сопоставь заявленные узлы графа с фактическим публичным API.
- Определи разрыв между желаемой чистой архитектурой и текущей реализацией.

Структура итогового отчёта:
0) Executive summary
1) Соответствие Clean Architecture / RPG-графу
2) Публичный API и стабильность
3) Удобство интеграции (боты/веб)
4) Миграции vs runtime (dual URL) — DX и безопасность
5) DTO и сериализация
6) Telegram пример — применимость
7) Производительность / масштабирование
8) Совместимость и зависимости
9) Качество документации
10) Предлагаемые рефакторинги (ROI-ordered)
11) Дорожная карта (топологический порядок)
12) Интеграционный рецепт (как должно стать)
Приложения: чек-лист соответствия, список опечаток.

Критерии оценки удобства использования:
- Простота получения рабочей конфигурации (env, миграции).
- Глубина импортов (есть ли фасад SDK).
- Ясность контрактов ошибок.
- Наличие примеров и их полнота.
- Асинхронная модель (UoW per operation) — легко ли соблюсти.

Сформируй конкретные, измеримые рекомендации: какие файлы создать/изменить, какие публичные объекты экспортировать, порядок внедрения (топологически), какие тесты добавить.
Не дублируй код, если не требуется; фокусируйся на архитектурных шагах.
Создай граф реализации предложенных изменений (RPG) в дополнение к отчёту и разместит его рядом с rpg_py_accountant.yaml.
Размер итераций должен быть таким. чтобы у LLM (GPT-5) не происходило переполнение контекста при выполнении итерации. 
"""
