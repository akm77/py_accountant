# Техника Repository Planning Graph (RPG) для работы с большими проектами

## Основная идея

При работе с крупными проектами используй **структурированный граф планирования** вместо расплывчатых текстовых описаний. Граф RPG — это единое представление, где узлы содержат компоненты проекта, а рёбра фиксируют их связи и порядок реализации.

## Структура графа

### Узлы (двойная семантика)
- **Функциональный уровень**: возможности системы
  - Корневые узлы = модули высокого уровня (authentication, data_processing, api)
  - Промежуточные узлы = компоненты (user_auth, data_validation)
  - Листовые узлы = конкретные функции/классы (validate_email, UserManager)

- **Структурный уровень**: организация кода
  - Корневые узлы = директории
  - Промежуточные узлы = файлы
  - Листовые узлы = функции/классы в файлах

### Рёбра (связи и порядок)
- **Межмодульные связи**: потоки данных между модулями
  - Пример: `DataLoader → Preprocessor → Model → Evaluator`

- **Внутримодульные связи**: порядок файлов внутри модуля
  - Пример: `config.py → utils.py → main.py`

## Процесс работы (3 этапа)

### 1. Планирование возможностей
```
Задача: Определить ЧТО строим

Действия:
- Декомпозируй требования на функциональные модули
- Организуй их в иерархию: система → подсистемы → компоненты
- Проверь полноту покрытия требований
- Выдели зависимости между модулями

Результат: Граф функций без деталей реализации
```

### 2. Планирование реализации
```
Задача: Определить КАК строим

Действия:
- Привяжи модули к директориям
- Распредели функции по файлам (группируй связанные)
- Определи интерфейсы: входы/выходы каждого компонента
- Построй топологический порядок: что от чего зависит
- Выдели общие абстракции (базовые классы, типы данных)

Результат: Полный RPG с файловой структурой и интерфейсами
```

### 3. Генерация кода по графу
```
Задача: Реализовать согласно плану

Действия:
- Обходи граф в топологическом порядке (от независимых к зависимым)
- Для каждого узла:
  1. Создай тест на основе спецификации
  2. Реализуй функцию/класс
  3. Прогони тест
  4. Если не прошёл — исправь (до 8 попыток)
  5. Только после успеха — коммить в репозиторий
- Используй граф для навигации при дебаге

Результат: Работающий репозиторий с валидированным кодом
```

## Ключевые принципы

### ✅ ДЕЛАЙ
1. **Явная структура**: всегда начинай с построения графа
2. **Топологический порядок**: реализуй зависимости раньше зависящих
3. **Стабильные интерфейсы**: фиксируй входы/выходы до реализации
4. **Модульность**: группируй связанные функции, разделяй несвязанные
5. **Инкрементальная валидация**: тести каждый компонент перед интеграцией

### ❌ НЕ ДЕЛАЙ
1. **Не полагайся на текстовые описания** для больших проектов
2. **Не меняй интерфейсы** после того, как они зафиксированы в графе
3. **Не реализуй компоненты** в произвольном порядке
4. **Не игнорируй зависимости** между модулями
5. **Не коммить код** до прохождения тестов

## Пример применения

```
Запрос: "Создай ML-библиотеку с алгоритмами кластеризации"

Этап 1 - Граф возможностей:
├─ data_lifecycle
│  ├─ loading (load_csv, load_json)
│  └─ preprocessing (normalize, handle_missing)
├─ clustering
│  ├─ kmeans (KMeans, KMeansPlusPlus)
│  └─ hierarchical (AgglomerativeClustering)
└─ evaluation
   └─ metrics (silhouette_score, davies_bouldin)

Этап 2 - Структура и интерфейсы:
data_lifecycle/
  ├─ loader.py: DataLoader(filepath) → ndarray
  └─ preprocess.py: Preprocessor(data) → ndarray
clustering/
  ├─ base.py: BaseClusterer (fit, predict)
  ├─ kmeans.py: KMeans(BaseClusterer)
  └─ hierarchical.py: Hierarchical(BaseClusterer)
evaluation/
  └─ metrics.py: compute_silhouette(data, labels) → float

Потоки данных:
DataLoader → Preprocessor → [KMeans, Hierarchical] → Metrics

Этап 3 - Порядок реализации:
1. base.py (не зависит ни от чего)
2. loader.py (независим)
3. preprocess.py (зависит от loader)
4. kmeans.py + hierarchical.py (зависят от base и preprocess)
5. metrics.py (зависит от clustering)
```

## Когда использовать RPG

- Проекты >1000 строк кода
- Множество взаимосвязанных модулей
- Сложные потоки данных
- Необходимость поддерживать согласованность интерфейсов
- Итеративная разработка с расширением функционала

## Преимущества подхода

1. **Масштабируемость**: поддержка проектов 30K+ строк кода
2. **Предсказуемость**: топологический порядок устраняет конфликты зависимостей
3. **Стабильность**: 70%+ pass rate на сложных проектах
4. **Навигация**: ускорение локализации багов на 30-50%
5. **Расширяемость**: линейный рост функциональности без деградации
