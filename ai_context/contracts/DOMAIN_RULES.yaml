# AI Context: Domain Rules & Invariants
# Версия: 1.1.0
# Последнее обновление: 2025-11-28
# Назначение: Все бизнес-правила и инварианты домена

---
# Double-Entry Invariant
---
double_entry:
  principle: "Every transaction must balance (sum debits = sum credits)"
  location: py_accountant.domain.transaction

  rule: |
    For any Transaction:
    sum(line.debit for line in lines) == sum(line.credit for line in lines)

  validation:
    when: "Transaction.create()"
    raises: "DomainError if invariant violated"

  examples:
    valid:
      - description: "Simple transfer"
        lines:
          - {full_name: "ASSET:CASH_USD", debit: "100.00", credit: "0.00"}
          - {full_name: "REVENUE:SERVICES", debit: "0.00", credit: "100.00"}
        result: "sum(debits)=100.00 == sum(credits)=100.00 ✓"

      - description: "Multi-line transaction"
        lines:
          - {full_name: "ASSET:CASH_USD", debit: "150.00", credit: "0.00"}
          - {full_name: "REVENUE:SERVICES", debit: "0.00", credit: "100.00"}
          - {full_name: "LIABILITY:VAT", debit: "0.00", credit: "50.00"}
        result: "sum(debits)=150.00 == sum(credits)=150.00 ✓"

    invalid:
      - description: "Unbalanced transaction"
        lines:
          - {full_name: "ASSET:CASH_USD", debit: "100.00", credit: "0.00"}
          - {full_name: "REVENUE:SERVICES", debit: "0.00", credit: "90.00"}
        result: "sum(debits)=100.00 != sum(credits)=90.00 ✗"
        raises: "DomainError: Transaction does not balance"

---
# Quantization Rules
---
quantization:
  money_amounts:
    precision: 2
    rounding: ROUND_HALF_EVEN
    function: money_quantize(value)
    location: py_accountant.domain.quantize
    examples:
      - input: "100.123"
        output: "100.12"
      - input: "100.125"
        output: "100.12"  # HALF_EVEN: round to nearest even
      - input: "100.135"
        output: "100.14"  # HALF_EVEN: round to nearest even

  exchange_rates:
    precision: 6
    rounding: ROUND_HALF_EVEN
    function: rate_quantize(value)
    location: py_accountant.domain.quantize
    examples:
      - input: "1.2345678"
        output: "1.234568"
      - input: "1.2345675"
        output: "1.234568"  # HALF_EVEN

  usage:
    rule: "All monetary amounts MUST be quantized before persistence"
    locations:
      - "Transaction lines (debit, credit)"
      - "Balance calculations"
      - "FX conversions"
      - "Trading balance aggregations"

---
# Account Validation
---
account_validation:
  full_name_format:
    pattern: "^[A-Z0-9]+:[A-Z0-9_]+$"
    structure: "TYPE:NAME"
    examples:
      valid:
        - "ASSET:CASH_USD"
        - "LIABILITY:LOAN_2024"
        - "REVENUE:SERVICES_Q1"
      invalid:
        - "asset:cash_usd"  # lowercase
        - "ASSET_CASH_USD"  # no colon
        - "ASSET:"  # empty name
        - ":CASH_USD"  # empty type

  account_type:
    enum: [ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE]
    rule: "TYPE part of full_name must match one of enum values"
    validation: "Account.create() checks TYPE part"

  currency_code:
    rule: "Must reference existing Currency"
    validation: "Use case checks currency exists before creating account"
    raises: "ValueError if currency not found"

  uniqueness:
    rule: "full_name must be unique"
    enforcement: "Database UNIQUE constraint + use case validation"

---
# Currency Validation
---
currency_validation:
  code_format:
    pattern: "^[A-Z]{3}$"
    examples:
      valid: ["USD", "EUR", "GBP", "BTC"]
      invalid: ["usd", "US", "USDT", "123"]

  base_currency:
    rule: "At most one currency can have is_base_currency=True"
    enforcement: "Application logic (not enforced at DB level)"
    note: "Having zero base currencies is allowed (for raw-only mode)"

  uniqueness:
    rule: "code must be unique"
    enforcement: "Database UNIQUE constraint + use case validation"

---
# FX Conversion Rules
---
fx_conversion:
  base_currency_rate:
    rule: "Base currency always has rate = 1.0"
    validation: "ConvertedAggregator checks is_base_currency"
    enforcement: "Automatic (not stored in exchange_rate_events)"

  non_base_currency_rate:
    rule: "Non-base currency MUST have a positive rate"
    validation: "ConvertedAggregator.aggregate() checks rate > 0"
    raises: "ValidationError if rate is None or <= 0"

  rate_lookup:
    rule: "Use latest rate <= as_of timestamp"
    implementation: "AsyncExchangeRateEventRepository.get_latest_rate()"

  conversion_formula:
    formula: "amount_base = amount * rate"
    quantization: "Result quantized to 2 decimals (money_quantize)"
    example:
      - amount: "100.00 EUR"
      - rate: "1.250000"
      - amount_base: "125.00 USD"

---
# Trading Balance Rules
---
trading_balance:
  raw_aggregation:
    rule: "Sum all ASSET account balances by currency_code"
    no_fx: true
    implementation: "RawAggregator"

  detailed_aggregation:
    rule: "Sum all ASSET account balances + convert to base currency"
    requires_base_currency: true
    requires_fx_rates: true
    implementation: "ConvertedAggregator"
    validation:
      - "Base currency must exist"
      - "All non-base currencies must have positive rate"

  account_type_filter:
    rule: "Only ASSET accounts included"
    reason: "Trading balance = total assets"

---
# Transaction Rules
---
transaction:
  minimum_lines:
    rule: "At least 2 lines required"
    reason: "Double-entry accounting requires at least 2 accounts"
    validation: "Transaction.create() checks len(lines) >= 2"

  line_amounts:
    rule: "debit >= 0 AND credit >= 0"
    rule2: "NOT (debit > 0 AND credit > 0)"
    reason: "Each line affects one side only"
    validation: "EntryLine validation"

  posted_at:
    rule: "Must be UTC datetime"
    default: "Clock.now() in use case"

  idempotency_key:
    rule: "Optional meta['idempotency_key'] for deduplication"
    enforcement: "Database UNIQUE constraint on idempotency_key"
    note: "Use case should handle IntegrityError for duplicates"

---
# FX Audit TTL Rules
---
fx_ttl:
  retention_period:
    rule: "Events older than cutoff are eligible for TTL"
    formula: "cutoff = now - retention_days"
    default: "90 days"

  modes:
    delete:
      description: "Permanently delete old events"
      warning: "Data loss - cannot be undone"
    archive:
      description: "Move old events to archive table"
      safety: "Data preserved in exchange_rate_events_archive"

  batch_processing:
    rule: "Process in batches to avoid long transactions"
    default_batch_size: 1000
    reason: "Performance + lock management"

  dry_run:
    rule: "dry_run=True returns plan without modifying data"
    use_case: "AsyncPlanFxAuditTTL always dry_run"
    execution: "AsyncExecuteFxAuditTTL for actual processing"

---
# Immutability Rules
---
immutability:
  transactions:
    rule: "Transactions are immutable after creation"
    reason: "Audit trail integrity"
    correction: "Create reversing transaction, not modify existing"

  accounts:
    rule: "Account full_name and type are immutable"
    reason: "Transaction references would break"
    allowed_changes: "metadata only"

  currencies:
    rule: "Currency code is immutable"
    allowed_changes: "name, is_base_currency"

---
# Async-Only Rules
---
async_architecture:
  use_cases:
    rule: "All use cases are async-only"
    location: "py_accountant.application.use_cases_async"
    pattern: "async def __call__(...)"

  repositories:
    rule: "All repositories are async"
    pattern: "async def get_by_..., async def add(...)"

  uow:
    rule: "AsyncUnitOfWork uses async context manager"
    pattern: "async with uow: ..."

  migrations:
    exception: "Alembic migrations use sync driver"
    reason: "Alembic limitation"
    location: "alembic/env.py"

---
# Error Handling Rules
---
error_handling:
  validation_errors:
    when: "Domain invariant violated"
    raises: "ValidationError (from py_accountant.domain.exceptions)"
    examples:
      - "Invalid full_name format"
      - "Double-entry invariant violated"
      - "Negative amount"

  not_found_errors:
    when: "Resource doesn't exist"
    raises: "ValueError"
    examples:
      - "Account not found"
      - "Currency not found"
      - "Transaction not found"

  business_rule_errors:
    when: "Business rule violated"
    raises: "DomainError"
    examples:
      - "Missing base currency for detailed trading balance"
      - "Missing FX rate for non-base currency"

---
# Layer Constraints
---
layer_constraints:
  domain:
    can:
      - "Define value objects and entities"
      - "Validate invariants"
      - "Raise DomainError/ValidationError"
    cannot:
      - "Import from application or infrastructure"
      - "Perform I/O (database, network, files)"
      - "Use async/await"

  application:
    can:
      - "Orchestrate domain objects"
      - "Use repositories via ports"
      - "Convert between domain objects and DTOs"
      - "Use async/await"
    cannot:
      - "Implement repositories (that's infrastructure)"
      - "Import from infrastructure (use ports instead)"

  infrastructure:
    can:
      - "Implement repositories"
      - "Database I/O"
      - "External API calls"
      - "Import from application and domain"
    cannot:
      - "Contain business logic (delegate to domain)"

---
# Summary Checklist
---
checklist:
  when_implementing_use_case:
    - "✓ Accept dependencies via constructor (UoW, Clock, etc.)"
    - "✓ Validate input DTOs"
    - "✓ Load domain objects from repositories"
    - "✓ Check business rules (call domain methods)"
    - "✓ Quantize all monetary amounts"
    - "✓ Persist via repositories"
    - "✓ Commit UoW"
    - "✓ Convert domain objects to DTOs for return"
    - "✓ Handle ValidationError and ValueError appropriately"

  when_implementing_domain_object:
    - "✓ No I/O (pure functions)"
    - "✓ Validate invariants in constructors"
    - "✓ Raise ValidationError on invalid input"
    - "✓ Use money_quantize/rate_quantize for amounts"
    - "✓ Immutable after creation (frozen dataclass recommended)"

  when_implementing_repository:
    - "✓ CRUD-only (no business logic)"
    - "✓ Return domain objects, not DTOs"
    - "✓ Return None for not found (don't raise)"
    - "✓ Raise ValidationError for invalid input"
    - "✓ Use async/await"
